#include "../s21_decimal.h"

int s21_from_float_to_decimal(float src, s21_decimal *dst) {
  int return_value = 0;
  if (!dst) return_value = 1;
  if (isinf(src) || isnan(src) || return_value) {
    return_value = 1;
  } else {
    s21_zero_decimal(dst);
    s21_set_sign(dst, 0);

    if (src != 0) {  // Проверяем, что входное число не равно нулю.
      int sign =
          *(int *)&src >> 31;  //  Извлекаем знак вещественного числа с помощью
                               //  побитовой операции сдвига на 31 бит
      int exp = ((*(int *)&src & ~0x80000000) >> 23) - 127;
      // 1. & ~0x80000000 - битовая операция AND с инвертированным значением
      // 0x80000000 (бит с индексом 31 равен 1,
      //    что соответствует знаку вещественного числа в IEEE 754).
      //    Это позволяет получить только биты, отвечающие за экспоненту в
      //    формате IEEE 754.
      // 2. >> 23 - сдвиг вправо на 23 бита, чтобы получить значение экспоненты.
      // 3. Вычитание 127 - в формате IEEE 754 экспонента хранится смещенной на
      // 127.
      //    Поэтому вычитание 127 позволяет получить истинное значение
      //    экспоненты.

      // Таким образом, код извлекает степень (экспоненту) вещественного числа
      // из его бинарного представления в формате IEEE 754, используя побитовые
      // операции и сдвиги.
      double temp = (double)fabs(src);
      int off = 0;  // Переменная off используется для отслеживания количества
                    // умножений на 10.

      for (; off < 28 && (int)temp / (int)pow(2, 21) == 0;
           temp *= 10,
           off++) {  // Преобразуем вещественное число в двойную точность и
                     // умножаем его на 10 до тех пор, пока целая часть числа не
                     // станет больше или равной 2^21
      }
      temp = round(temp);  // Округляем число с двойной точностью
      if (off <= 28 &&
          (exp > -94 &&
           exp < 96)) {  // Проверяем, что степень в диапазоне от -94 до 95
        floatbits mant = {0};  // извлекаем мантиссу вещественного числа с
                               // помощью объединения floatbits
        temp = (float)temp;
        for (; fmod(temp, 10) == 0 && off > 0; off--, temp /= 10) {
        }
        mant.fl = temp;
        exp = ((*(int *)&mant.fl & ~0x80000000) >> 23) - 127;
        // Устанавливаем соответствующие биты в структуре s21_decimal на основе
        // знака, экспоненты и мантиссы

        dst->bits[exp / 32] |= 1 << exp % 32;
        // Устанавливаем бит в массиве bits по индексу exp/32 и позиции exp%32

        for (int i = exp - 1, j = 22; j >= 0; i--, j--)
          if ((mant.ui & (1 << j)) != 0) dst->bits[i / 32] |= 1 << i % 32;
        // Проходим по битам мантиссы и устанавливаем соответствующие биты в
        // массиве bits

        dst->bits[3] = (sign << 31) | (off << 16);
        // Устанавливаем биты в массиве bits для знака и смещения
      }
    }
  }
  return return_value;
}
